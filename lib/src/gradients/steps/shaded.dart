/// Provides `FooShadedSteps`
library gradients;

import 'dart:math' as math;
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart' show listEquals, objectRuntimeType;

import '../common.dart';
import '../interpolation.dart';
import '../models.dart';
import 'operators.dart';
import 'steps.dart';

/// Return a list of stops that is four times the size of the original,
/// including potential maths performed on intermediate colors considering
/// [softness] and [distance].
List<double> _quadruple(
  List<double>? stops,
  List<Color> colors,
  double softness,
  double distance,
) {
  stops ??= List<double>.from(stopsOrImplied(stops, colors.length + 1))
    ..removeLast();
  return stops % ShadeStep(distance, softness);
}

class LinearShadedSteps extends LinearSteps {
  const LinearShadedSteps({
    this.shadeFunction = Shades.withWhite,
    this.shadeFactor = -90,
    this.distance = 0.6,
    double softness = 0.0,
    required List<Color> colors,
    List<double>? stops,
    AlignmentGeometry begin = Alignment.centerLeft,
    AlignmentGeometry end = Alignment.centerRight,
    TileMode tileMode = TileMode.clamp,
    GradientTransform? transform,
  }) : super(
          softness: softness,
          colors: colors,
          stops: stops,
          begin: begin,
          end: end,
          tileMode: tileMode,
          transform: transform,
        );

  final ColorArithmetic shadeFunction;
  final num shadeFactor;
  final double distance;

  @override
  List<Color> get steppedColors =>
      colors ^ Shade(function: shadeFunction, factor: shadeFactor);

  @override
  List<double> get steppedStops =>
      _quadruple(stops, colors, softness, distance);

  /// ðŸ“‹ Returns a new copy of this `LinearShadedSteps` with any provided
  /// optional parameters overriding those of `this`.
  @override
  LinearShadedSteps copyWith({
    ColorArithmetic? shadeFunction,
    int? shadeFactor,
    double? distance,
    double? softness,
    List<Color>? colors,
    List<double>? stops,
    AlignmentGeometry? begin,
    AlignmentGeometry? end,
    TileMode? tileMode,
    GradientTransform? transform,
  }) =>
      LinearShadedSteps(
        shadeFunction: shadeFunction ?? this.shadeFunction,
        shadeFactor: shadeFactor ?? this.shadeFactor,
        distance: distance ?? this.distance,
        softness: softness ?? this.softness,
        colors: colors ?? this.colors,
        stops: stops ?? this.stops,
        begin: begin ?? this.begin,
        end: end ?? this.end,
        tileMode: tileMode ?? this.tileMode,
        transform: transform ?? this.transform,
      );

  /// Returns a new [LinearSteps] with its colors scaled by the given factor.
  /// Since the alpha channel is what receives the scale factor,
  /// `0.0` or less results in a gradient that is fully transparent.
  @override
  LinearShadedSteps scale(double factor) => copyWith(
        colors: colors
            .map<Color>((Color color) => Color.lerp(null, color, factor)!)
            .toList(),
      );

  @override
  Gradient? lerpFrom(Gradient? a, double t) =>
      (a == null || (a is LinearShadedSteps))
          ? LinearShadedSteps.lerp(a as LinearShadedSteps?, this, t)
          : super.lerpFrom(a, t);

  @override
  Gradient? lerpTo(Gradient? b, double t) =>
      (b == null || (b is LinearShadedSteps))
          ? LinearShadedSteps.lerp(this, b as LinearShadedSteps?, t)
          : super.lerpTo(b, t);

  /// Linearly interpolate between two [LinearSteps].
  ///
  /// If either `LinearSteps` is `null`, this function linearly interpolates
  /// from a `LinearSteps` that matches the other in [begin], [end], [stops] and
  /// [tileMode] and with the same [colors] but transparent (using [scale]).
  ///
  /// The `t` argument represents a position on the timeline, with `0.0` meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), `1.0` meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond `0.0`
  /// and `1.0`, so negative values and values greater than `1.0` are valid
  /// (and can easily be generated by curves such as `Curves.elasticInOut`).
  ///
  /// Values for `t` are usually obtained from an [Animation<double>],
  /// such as an `AnimationController`.
  static Gradient? lerp(LinearShadedSteps? a, LinearShadedSteps? b, double t) {
    if (a == null && b == null) return null;
    if (a == null) return b!.scale(t);
    if (b == null) return a.scale(1.0 - t);
    // return GradientTween(begin: a, end: b).lerp(t);
    final stretched = PrimitiveGradient.fromStretchLerp(a, b, t);
    final interpolated = PrimitiveGradient.byProgressiveMerge(
        t < 0.5 ? PrimitiveGradient.from(a) : stretched,
        t < 0.5 ? stretched : PrimitiveGradient.from(b),
        // t < 0.5 ? t * 2 : (t - 0.5) * 2);
        t);

    // // final interpolated = PrimitiveGradient.byCombination(a, b, t);
    // // final interpolated = PrimitiveGradient.fromStretchLerp(a, b, t);
    // // final interpolated = PrimitiveGradient.byProgressiveMerge(
    // // PrimitiveGradient.from(a), PrimitiveGradient.from(b), t);
    return LinearShadedSteps(
      // shadeFactor:StepTween(begin: a.shadeFactor,end: b.shadeFactor).lerp(t),
      shadeFactor: Tween<double>(
              begin: a.shadeFactor.toDouble(), end: b.shadeFactor.toDouble())
          .transform(t),
      distance: math.max(0.0, ui.lerpDouble(a.distance, b.distance, t)!),
      softness: math.max(0.0, ui.lerpDouble(a.softness, b.softness, t)!),
      colors: interpolated.colors,
      stops: interpolated.stops,
      // TODO: Interpolate Matrix4 / GradientTransform
      transform: t > 0.5 ? a.transform : b.transform,
      // TODO: interpolate tile mode
      tileMode: t < 0.5 ? a.tileMode : b.tileMode,
      begin: AlignmentGeometry.lerp(a.begin, b.begin, t)!,
      end: AlignmentGeometry.lerp(a.end, b.end, t)!,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other.runtimeType != runtimeType) return false;
    return other is LinearShadedSteps &&
        other.shadeFunction == shadeFunction &&
        other.shadeFactor == shadeFactor &&
        other.distance == distance &&
        other.softness == softness &&
        listEquals<Color>(other.colors, colors) &&
        listEquals<double>(other.stops, stops) &&
        other.tileMode == tileMode &&
        other.begin == begin &&
        other.end == end;
  }

  @override
  int get hashCode => hashValues(shadeFunction, shadeFactor, distance, softness,
      hashList(colors), hashList(stops), tileMode, begin, end);

  @override
  String toString() => '${objectRuntimeType(this, 'LinearShadedSteps')} '
      '(shade: $shadeFactor, distance: $distance, softness: $softness, '
      'colors: $colors, stops: $stops, $tileMode, '
      'begin: $begin, end: $end)';
  // ', \nresolved colors: $steppedColors, resolved stops: $steppedStops';
}

class RadialShadedSteps extends RadialSteps {
  const RadialShadedSteps({
    this.shadeFunction = Shades.withWhite,
    this.shadeFactor = -90,
    this.distance = 0.6,
    double softness = 0.0,
    required List<Color> colors,
    List<double>? stops,
    AlignmentGeometry center = Alignment.center,
    double radius = 0.5,
    AlignmentGeometry? focal,
    double focalRadius = 0.0,
    TileMode tileMode = TileMode.clamp,
    GradientTransform? transform,
  }) : super(
          softness: softness,
          colors: colors,
          stops: stops,
          center: center,
          radius: radius,
          focal: focal,
          focalRadius: focalRadius,
          tileMode: tileMode,
          transform: transform,
        );

  final ColorArithmetic shadeFunction;
  final num shadeFactor;
  final double distance;

  @override
  List<Color> get steppedColors =>
      colors ^ Shade(function: shadeFunction, factor: shadeFactor);

  @override
  List<double> get steppedStops =>
      _quadruple(stops, colors, softness, distance);

  /// ðŸ“‹ Returns a new copy of this `RadialShadedSteps` with any provided
  /// optional parameters overriding those of `this`.
  @override
  RadialShadedSteps copyWith({
    ColorArithmetic? shadeFunction,
    int? shadeFactor,
    double? distance,
    double? softness,
    List<Color>? colors,
    List<double>? stops,
    TileMode? tileMode,
    AlignmentGeometry? center,
    double? radius,
    AlignmentGeometry? focal,
    double? focalRadius,
    GradientTransform? transform,
  }) =>
      RadialShadedSteps(
        shadeFunction: shadeFunction ?? this.shadeFunction,
        shadeFactor: shadeFactor ?? this.shadeFactor,
        distance: distance ?? this.distance,
        softness: softness ?? this.softness,
        colors: colors ?? this.colors,
        stops: stops ?? this.stops,
        transform: transform ?? this.transform,
        tileMode: tileMode ?? this.tileMode,
        center: center ?? this.center,
        radius: radius ?? this.radius,
        focal: focal ?? this.focal,
        focalRadius: focalRadius ?? this.focalRadius,
      );

  /// Returns a new [RadialSteps] with its colors scaled by the given factor.
  /// Since the alpha channel is what receives the scale factor,
  /// `0.0` or less results in a gradient that is fully transparent.
  @override
  RadialShadedSteps scale(double factor) => copyWith(
        colors: colors
            .map<Color>((Color color) => Color.lerp(null, color, factor)!)
            .toList(),
      );

  @override
  Gradient? lerpFrom(Gradient? a, double t) =>
      (a == null || (a is RadialShadedSteps))
          ? RadialShadedSteps.lerp(a as RadialShadedSteps?, this, t)
          : super.lerpFrom(a, t);

  @override
  Gradient? lerpTo(Gradient? b, double t) =>
      (b == null || (b is RadialShadedSteps))
          ? RadialShadedSteps.lerp(this, b as RadialShadedSteps?, t)
          : super.lerpTo(b, t);

  /// Linearly interpolate between two [RadialShadedSteps]s.
  ///
  /// If either gradient is null, this function linearly interpolates from a
  /// a gradient that matches the other gradient in [center], [radius], [stops]
  /// and [tileMode] and with the same [colors] but transparent (using [scale]).
  ///
  /// The `t` argument represents a position on the timeline, with 0.0 meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  /// 1.0, so negative values and values greater than 1.0 are valid (and can
  /// easily be generated by curves such as `Curves.elasticInOut`).
  ///
  /// Values for `t` are usually obtained from an [Animation<double>], such as
  /// an `AnimationController`.
  static RadialShadedSteps? lerp(
      RadialShadedSteps? a, RadialShadedSteps? b, double t) {
    if (a == null && b == null) return null;
    if (a == null) return b!.scale(t);
    if (b == null) return a.scale(1.0 - t);
    final stretched = PrimitiveGradient.fromStretchLerp(a, b, t);
    final interpolated = PrimitiveGradient.byProgressiveMerge(
        t < 0.5 ? PrimitiveGradient.from(a) : stretched,
        t < 0.5 ? stretched : PrimitiveGradient.from(b),
        // t < 0.5 ? t * 2 : (t - 0.5) * 2);
        t);

    // final interpolated = PrimitiveGradient.byCombination(a, b, t);
    // final interpolated = PrimitiveGradient.fromStretchLerp(a, b, t);
    // final interpolated = PrimitiveGradient.byProgressiveMerge(
    // PrimitiveGradient.from(a), PrimitiveGradient.from(b), t);
    return RadialShadedSteps(
      // shadeFactor:StepTween(begin: a.shadeFactor,end: b.shadeFactor).lerp(t),
      shadeFactor: Tween<double>(
              begin: a.shadeFactor.toDouble(), end: b.shadeFactor.toDouble())
          .transform(t),
      distance: math.max(0.0, ui.lerpDouble(a.distance, b.distance, t)!),
      softness: math.max(0.0, ui.lerpDouble(a.softness, b.softness, t)!),
      colors: interpolated.colors,
      stops: interpolated.stops,
      // TODO: Interpolate Matrix4 / GradientTransform
      transform: t > 0.5 ? a.transform : b.transform,
      // TODO: interpolate tile mode
      tileMode: t < 0.5 ? a.tileMode : b.tileMode,
      center: AlignmentGeometry.lerp(a.center, b.center, t)!,
      radius: math.max(0.0, ui.lerpDouble(a.radius, b.radius, t)!),
      focal: AlignmentGeometry.lerp(a.focal, b.focal, t),
      focalRadius:
          math.max(0.0, ui.lerpDouble(a.focalRadius, b.focalRadius, t)!),
    );
  }

  @override
  bool operator ==(Object other) => (identical(this, other))
      ? true
      : (other.runtimeType != runtimeType)
          ? false
          : other is RadialShadedSteps &&
              other.shadeFunction == shadeFunction &&
              other.shadeFactor == shadeFactor &&
              other.distance == distance &&
              other.softness == softness &&
              listEquals<Color>(other.colors, colors) &&
              listEquals<double>(other.stops, stops) &&
              other.tileMode == tileMode &&
              other.center == center &&
              other.radius == radius &&
              other.focal == focal &&
              other.focalRadius == focalRadius;

  @override
  int get hashCode => hashValues(
      shadeFunction,
      shadeFactor,
      distance,
      softness,
      hashList(colors),
      hashList(stops),
      tileMode,
      center,
      radius,
      focal,
      focalRadius);

  @override
  String toString() => '${objectRuntimeType(this, 'RadialShadedSteps')}'
      '(softness: $softness, shade: $shadeFactor, distance: $distance, '
      'colors: $colors, stops: $stops, $tileMode, '
      'center: $center, radius: $radius, '
      'focal: $focal, focalRadius: $focalRadius)';
  // ', \nresolved colors: $steppedColors, resolved stops: $steppedStops';
}

class SweepShadedSteps extends SweepSteps {
  const SweepShadedSteps({
    this.shadeFunction = Shades.withWhite,
    this.shadeFactor = -90,
    this.distance = 0.6,
    double softness = 0.0,
    required List<Color> colors,
    List<double>? stops,
    TileMode tileMode = TileMode.clamp,
    AlignmentGeometry center = Alignment.center,
    double startAngle = 0.0,
    double endAngle = math.pi * 2,
    GradientTransform? transform,
  }) : super(
          softness: softness,
          colors: colors,
          stops: stops,
          center: center,
          startAngle: startAngle,
          endAngle: endAngle,
          tileMode: tileMode,
          transform: transform,
        );

  final ColorArithmetic shadeFunction;
  final num shadeFactor;
  final double distance;

  @override
  List<Color> get steppedColors =>
      colors ^ Shade(function: shadeFunction, factor: shadeFactor);

  @override
  List<double> get steppedStops =>
      _quadruple(stops, colors, softness, distance);

  /// ðŸ“‹ Returns a new copy of this `SweepShadedSteps` with any provided
  /// optional parameters overriding those of `this`.
  @override
  SweepShadedSteps copyWith({
    ColorArithmetic? shadeFunction,
    int? shadeFactor,
    double? distance,
    double? softness,
    List<Color>? colors,
    List<double>? stops,
    TileMode? tileMode,
    AlignmentGeometry? center,
    double? startAngle,
    double? endAngle,
    GradientTransform? transform,
  }) =>
      SweepShadedSteps(
        shadeFunction: shadeFunction ?? this.shadeFunction,
        shadeFactor: shadeFactor ?? this.shadeFactor,
        distance: distance ?? this.distance,
        softness: softness ?? this.softness,
        colors: colors ?? this.colors,
        stops: stops ?? this.stops,
        center: center ?? this.center,
        startAngle: startAngle ?? this.startAngle,
        endAngle: endAngle ?? this.endAngle,
        tileMode: tileMode ?? this.tileMode,
        transform: transform ?? this.transform,
      );

  /// Returns a new [SweepSteps] with its colors scaled by the given factor.
  /// Since the alpha channel is what receives the scale factor,
  /// `0.0` or less results in a gradient that is fully transparent.
  @override
  SweepShadedSteps scale(double factor) => copyWith(
        colors: colors
            .map<Color>((Color color) => Color.lerp(null, color, factor)!)
            .toList(),
      );

  @override
  Gradient? lerpFrom(Gradient? a, double t) =>
      (a == null || (a is SweepShadedSteps))
          ? SweepShadedSteps.lerp(a as SweepShadedSteps?, this, t)
          : super.lerpFrom(a, t);

  @override
  Gradient? lerpTo(Gradient? b, double t) =>
      (b == null || (b is SweepShadedSteps))
          ? SweepShadedSteps.lerp(this, b as SweepShadedSteps?, t)
          : super.lerpTo(b, t);

  /// Linearly interpolate between two [SweepShadedSteps]s.
  ///
  /// If either gradient is null, then the non-null gradient is returned with
  /// its color scaled in the same way as the [scale] function.
  ///
  /// The `t` argument represents a position on the timeline, with 0.0 meaning
  /// that the interpolation has not started, returning `a` (or something
  /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
  /// returning `b` (or something equivalent to `b`), and values in between
  /// meaning that the interpolation is at the relevant point on the timeline
  /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
  /// 1.0, so negative values and values greater than 1.0 are valid (and can
  /// easily be generated by curves such as `Curves.elasticInOut`).
  ///
  /// Values for `t` are usually obtained from an [Animation<double>], such as
  /// an `AnimationController`.
  static SweepShadedSteps? lerp(
      SweepShadedSteps? a, SweepShadedSteps? b, double t) {
    if (a == null && b == null) return null;
    if (a == null) return b!.scale(t);
    if (b == null) return a.scale(1.0 - t);
    final stretched = PrimitiveGradient.fromStretchLerp(a, b, t);
    final interpolated = PrimitiveGradient.byProgressiveMerge(
        t < 0.5 ? PrimitiveGradient.from(a) : stretched,
        t < 0.5 ? stretched : PrimitiveGradient.from(b),
        // t < 0.5 ? t * 2 : (t - 0.5) * 2);
        t);

    // final interpolated = PrimitiveGradient.byCombination(a, b, t);
    // final interpolated = PrimitiveGradient.fromStretchLerp(a, b, t);
    // final interpolated = PrimitiveGradient.byProgressiveMerge(
    // PrimitiveGradient.from(a), PrimitiveGradient.from(b), t);
    return SweepShadedSteps(
      // shadeFactor: StepTween(begin:a.shadeFactor, end:b.shadeFactor).lerp(t),
      shadeFactor: Tween<double>(
              begin: a.shadeFactor.toDouble(), end: b.shadeFactor.toDouble())
          .transform(t),
      distance: math.max(0.0, ui.lerpDouble(a.distance, b.distance, t)!),
      softness: math.max(0.0, ui.lerpDouble(a.softness, b.softness, t)!),
      colors: interpolated.colors,
      stops: interpolated.stops,
      // TODO: Interpolate Matrix4 / GradientTransform
      transform: t > 0.5 ? a.transform : b.transform,
      // TODO: interpolate tile mode
      tileMode: t < 0.5 ? a.tileMode : b.tileMode,
      center: AlignmentGeometry.lerp(a.center, b.center, t)!,
      startAngle: math.max(0.0, ui.lerpDouble(a.startAngle, b.startAngle, t)!),
      endAngle: math.max(0.0, ui.lerpDouble(a.endAngle, b.endAngle, t)!),
    );
  }

  @override
  bool operator ==(Object other) => (identical(this, other))
      ? true
      : (other.runtimeType != runtimeType)
          ? false
          : other is SweepShadedSteps &&
              other.shadeFunction == shadeFunction &&
              other.shadeFactor == shadeFactor &&
              other.distance == distance &&
              other.softness == softness &&
              listEquals<Color>(other.colors, colors) &&
              listEquals<double>(other.stops, stops) &&
              other.center == center &&
              other.startAngle == startAngle &&
              other.endAngle == endAngle &&
              other.tileMode == tileMode;

  @override
  int get hashCode => hashValues(
      shadeFunction,
      shadeFactor,
      distance,
      softness,
      hashList(colors),
      hashList(stops),
      tileMode,
      center,
      startAngle,
      endAngle);

  @override
  String toString() => '${objectRuntimeType(this, 'SweepShadedSteps')}'
      '(softness: $softness, shade: $shadeFactor, distance: $distance, '
      'colors: $colors, stops: $stops, $tileMode, center: $center, '
      'startAngle: $startAngle, endAngle: $endAngle)';
  // ', \nresolved colors: $steppedColors, resolved stops: $steppedStops';
}
